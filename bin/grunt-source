#!/usr/bin/env node

var colors = { red:'\u001b[31m', blue:'\u001b[34m', reset: '\u001b[0m' },
    util = require('util'),
    fs = require('fs'),
    path = require('path'),
    mkdirp = require('mkdirp'),
    child = require('child_process'),
    defaultFileName = "Gruntsource.json",
    ONE_DAY = 1000 * 60 * 60 * 24,
    home = process.env.USERPROFILE || process.env.HOME || process.env.HOMEPATH;

var config = null;
//get config and run
if(fs.existsSync(defaultFileName)) {
  try {
    config = JSON.parse(fs.readFileSync(defaultFileName));
  } catch(e) {
    exit("Configuration file '%s' has an error: %s", defaultFileName, e);
  }
} else if(fs.existsSync("package.json")) {
  try {
    var pkg = JSON.parse(fs.readFileSync("package.json"));
    config = pkg.gruntSource;
  } catch(e) {
    exit("package.json file has an error: %s", e);
  }
}

if(!config)
  exit("Configuration file '%s' not found.", defaultFileName);

if(!config.source)
  exit("Configuration is missing the 'source' property");

if(/^~/.test(config.source))
  config.source = path.join(home, config.source.replace(/^~/,''));

if(fs.existsSync(config.source))
  pull();
else if(config.repo)
  checkout();
else
  exit("Source directory '%s' not found." +
    " Try adding a 'repo' to your configuration.", config.source);

// =======================

function validateSource() {
  //TODO
  //git remote -v show === config.repo
}

function checkout() {
  log("Creating Source... (git clone)");
  mkdirp.sync(path.dirname(config.source));
  spawn("git", ['clone', config.repo, config.source], function (err) {
    if(err) exit("Git clone error");
    update();
  });
}

function update() {
  log("Updating Source Modules... (npm install)");

  if(!fs.existsSync(path.join(config.source,'package.json')))
    exit("Source directory has no 'package.json'");

  spawn("npm", ["install"], { cwd: config.source }, function(err) {
    if(err) exit("Error npm updating");
    run();
  });
}

function pull() {
  var fetchHead = path.join(config.source,'.git','FETCH_HEAD');

  //pull once per day
  if(fs.existsSync(fetchHead) &&
     Date.now() - fs.statSync(fetchHead).atime.getTime() > ONE_DAY) {
    log("Updating Source... (git pull)", config.source);
    spawn("git", ['pull'], {
      cwd: config.source
    }, function (err) {
      if(err) exit("Git pull error");
      update();
    });
  } else {
    run();
  }
}

function run() {
  var args = process.argv.slice(2).concat(['--basedir', process.cwd()]);

  spawn(path.join(__dirname,'..','node_modules','grunt-cli','bin','grunt'), args, {
    cwd: config.source
  }, function(err) {
    if(err) exit("grunt-source error!");
    log('grunt-source done');
  });
}

function log() {
  console.log(colors.blue + util.format.apply(util, arguments) + colors.reset);
}

function exit() {
  console.log(colors.red + util.format.apply(util, arguments) + colors.reset);
  process.exit(1);
}

function spawn() {
  var args = Array.prototype.slice.call(arguments);
  var callback = args.pop();
  var proc = child.spawn.apply(child, args);
  proc.stdout.pipe(process.stdout);
  proc.stderr.pipe(process.stderr);
  proc.on('close', function (code) {
    callback(code === 0 ? null : "error");
  });
  return proc;
}

